{"version":3,"file":"worker-bundle.js","sources":["webpack:///webpack/bootstrap ea6650604ea24dd3d64e?f8e6","webpack:///src/core/rules.js?c763","webpack:///src/core/analyzer.js","webpack:///src/core/default_evaluator.js","webpack:///src/core/evaluator.js","webpack:///src/worker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 269);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ea6650604ea24dd3d64e","'use strict';\n\nexport default class Rules {\n  constructor(board, side) {\n    this.board = board;\n    this.side = side;\n  }\n\n  findJumps() {\n    let { board, side } = this,\n        top = side == 1 ? 7 : 0,\n        out = top + side,\n        bottom = top ^ 7,\n        jumps = [];\n\n    // loop through playable squares\n    for (let y = bottom; y != out; y += side) {\n      for (let x = bottom; x != out; x += side) {\n        // see if it's our piece\n        let p = board[y][x];\n\n        if (side * p > 0) {\n          // checking for jumps is inherently recursive - as long as you find them,\n          // you have to keep looking, and only termimal positions are valid\n          this.nextJump([[x, y]], jumps);\n        }\n      }\n    }\n\n    return jumps;\n  }\n\n  nextJump(cur, jumps) {\n    let { board, side } = this,\n        [x, y] = cur[cur.length - 1],\n        p = board[y][x],\n        top = side == 1 ? 7 : 0,\n        king = p == side * 2,\n        found = false;\n\n    // loop over directions (dx, dy) from the current square\n    for (let dy = king ? -1 : 1; dy != 3; dy += 2) {\n      for (let dx = -1; dx != 3; dx += 2) {\n        let mx, my, nx, ny;\n\n        // calculate middle and landing coordinates\n        if (side == 1) {\n          mx = x + dx;\n          my = y + dy;\n          nx = mx + dx;\n          ny = my + dy;\n        } else {\n          mx = x - dx;\n          my = y - dy;\n          nx = mx - dx;\n          ny = my - dy;\n        }\n\n        // see if jump is on the board\n        if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {\n          let m = board[my][mx],\n              n = board[ny][nx];\n\n          // see if the middle piece is an opponent and the landing is open\n          if (n == 0 && side * m < 0) {\n            let crowned = !king && ny == top;\n            found = true;\n\n            // keep track of the coordinates, and move the piece\n            board[y][x] = 0;\n            board[my][mx] = 0;\n            board[ny][nx] = crowned ? p * 2 : p;\n\n            // if we're crowned, or there are no further jumps from here,\n            // we've reached a terminal position\n            cur.push([nx, ny, mx, my]);\n            if (crowned || !this.nextJump(cur, jumps)) {\n              jumps.push(cur.slice());\n            }\n\n            // put things back where we found them\n            cur.pop();\n            board[y][x] = p;\n            board[my][mx] = m;\n            board[ny][nx] = 0;\n          }\n        }\n      }\n    }\n\n    // return whether more jumps were found from this position\n    return found;\n  }\n\n  withJump(jump, action) {\n    let { board, side } = this,\n        len = jump.length,\n        [x, y] = jump[0],\n        [fx, fy] = jump[len - 1],\n        p = board[y][x],\n        top = side == 1 ? 7 : 0,\n        crowned = p == side && fy == top,\n        cap = new Array(len);\n\n    // remove the initial piece\n    cap[0] = p;\n    board[y][x] = 0;\n\n    // loop over the passed in coords\n    for (let i = 1; i < len; ++i) {\n      let [,, mx, my] = jump[i];\n\n      // perform the jump\n      cap[i] = board[my][mx];\n      board[my][mx] = 0;\n    }\n\n    // final piece\n    board[fy][fx] = crowned ? p * 2 : p;\n\n    // do the action\n    action();\n\n    // remove the final piece\n    board[fy][fx] = 0;\n\n    // loop over the passed in coords in reverse\n    for (let i = len - 1; i > 0; --i) {\n      let [,, mx, my] = jump[i];\n\n      // put back the captured piece\n      board[my][mx] = cap[i];\n    }\n\n    // put back initial piece\n    board[y][x] = p;\n  }\n\n  findMoves() {\n    let { board, side } = this,\n        top = side == 1 ? 7 : 0,\n        out = top + side,\n        bottom = top ^ 7,\n        moves = [];\n\n    // loop through playable squares\n    for (let y = bottom; y != out; y += side) {\n      for (let x = bottom; x != out; x += side) {\n        let p = board[y][x],\n            king = p == side * 2;\n\n        // see if it's our piece\n        if (side * p > 0) {\n          // loop over directions (dx, dy) from the current square\n          for (let dy = king ? -1 : 1; dy != 3; dy += 2) {\n            for (let dx = -1; dx != 3; dx += 2) {\n              let nx, ny;\n\n              // calculate landing coordinates\n              if (side == 1) {\n                nx = x + dx;\n                ny = y + dy;\n              } else {\n                nx = x - dx;\n                ny = y - dy;\n              }\n\n              // see if move is on the board\n              if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {\n                let crowned = !king && ny == top;\n\n                // see if the landing is open\n                if (board[ny][nx] == 0) {\n                  // keep track of the coordinates, and move the piece\n                  board[y][x] = 0;\n                  board[ny][nx] = crowned ? p * 2 : p;\n\n                  moves.push([[x, y], [nx, ny]]);\n\n                  // put things back where we found them\n                  board[y][x] = p;\n                  board[ny][nx] = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return moves;\n  }\n\n  withMove(move, action) {\n    let { board, side } = this,\n        [[x, y], [nx, ny]] = move,\n        p = board[y][x],\n        top = side == 1 ? 7 : 0,\n        crowned = p == side && ny == top;\n\n    // perform the jump\n    board[y][x] = 0;\n    board[ny][nx] = crowned ? p * 2 : p;\n\n    // do the action\n    action();\n\n    // put things back where we found them\n    board[ny][nx] = 0;\n    board[y][x] = p;\n  }\n\n  findPlays(block) {\n    let jumps = this.findJumps();\n\n    // you have to jump if you can\n    if (jumps.length) {\n      return jumps;\n    } else {\n      return this.findMoves();\n    }\n  }\n\n  buildTree() {\n    let plays = this.findPlays(),\n        tree = {};\n\n    for (let i = 0; i < plays.length; ++i) {\n      let play = plays[i],\n          root = tree;\n\n      for (let j = 0; j < play.length; ++j) {\n        let [x, y] = play[j],\n            k = `${x},${y}`;\n\n        root[k] = root[k] || {};\n        root = root[k];\n      }\n    }\n\n    return tree;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// src/core/rules.js","'use strict';\n\nimport Rules from './rules';\nimport defaultEvaluator from './default_evaluator';\n\nexport default class Analyzer extends Rules {\n  constructor(board, side) {\n    super(board, side);\n\n    // use default evaluator for both sides (but feel free to change it)\n    this.redEval = this.whiteEval = defaultEvaluator;\n\n    // how many levels deep to search the tree\n    this.level = 8;\n  }\n\n  evaluate() {\n    // delegate to the current player's evaluator\n    let playerEval = this.side == 1 ? this.redEval : this.whiteEval;\n\n    return playerEval.evaluate(this.board);\n  }\n\n  run() {\n    // keep track of the current player's evaluator when switching sides\n    let player = this.side == 1 ? this.redEval : this.whiteEval;\n\n    // start at the top level\n    return this.loop(this.level, player);\n  }\n\n  loop(level, player) {\n    let { board, side } = this,\n        bestScore = -side * Infinity,\n        bestPlay,\n        current;\n\n    // always try to find counter-jumps from this position\n    let jumps = this.findJumps();\n\n    if (jumps.length) {\n      for (let i = 0; i < jumps.length; ++i) {\n        let jump = jumps[i];\n\n        this.withJump(jump, () => {\n          // switch sides and descend a level\n          this.side = -side;\n          current = this.loop(level - 1, player)[1];\n          this.side = side;\n        });\n\n        // keep track of the best move from this position\n        if ((side == +1 && current > bestScore) ||\n            (side == -1 && current < bestScore)) {\n          bestPlay = jump;\n          bestScore = current;\n        }\n      }\n    } else {\n      current = player.evaluate(board);\n\n      // see if we've hit bottom\n      if (level <= 0) {\n        // return score for this position\n        bestScore = current;\n      } else {\n        // find counter-moves from this position\n        let moves = this.findMoves();\n\n        for (let i = 0; i < moves.length; ++i) {\n          let move = moves[i];\n\n          this.withMove(move, () => {\n            // switch sides and descend a level\n            this.side = -side;\n            current = this.loop(level - 1, player)[1];\n            this.side = side;\n          });\n\n          // keep track of the best move from this position\n          if ((side == +1 && current > bestScore) ||\n              (side == -1 && current < bestScore)) {\n            bestPlay = move;\n            bestScore = current;\n          }\n        }\n      }\n    }\n\n    // a pair representing the winning play and score for this turn\n    return [bestPlay, bestScore];\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// src/core/analyzer.js","'use strict';\n\nimport Evaluator from './evaluator';\n\nconst defaultEvaluator = new Evaluator();\n\n// basic piece values\ndefaultEvaluator.addFormation([\n  [  0,  0, +1 ]\n], [\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [ 50,  0, 50,  0, 50,  0, 50,  0 ],\n  [  0, 50,  0, 50,  0, 50,  0, 50 ],\n  [ 50,  0, 50,  0, 50,  0, 50,  0 ],\n  [  0, 50,  0, 50,  0, 50,  0, 50 ],\n  [ 50,  0, 50,  0, 50,  0, 50,  0 ],\n  [  0, 50,  0, 50,  0, 50,  0, 50 ],\n  [ 50,  0, 50,  0, 50,  0, 50,  0 ]\n].reverse());\n\n// basic king values\ndefaultEvaluator.addFormation([\n  [  0,  0, +2 ]\n], [\n  [  0, 60,  0, 60,  0, 60,  0, 60 ],\n  [ 60,  0, 60,  0, 60,  0, 60,  0 ],\n  [  0, 60,  0, 60,  0, 60,  0, 60 ],\n  [ 60,  0, 60,  0, 60,  0, 60,  0 ],\n  [  0, 60,  0, 60,  0, 60,  0, 60 ],\n  [ 60,  0, 60,  0, 60,  0, 60,  0 ],\n  [  0, 60,  0, 60,  0, 60,  0, 60 ],\n  [ 60,  0, 60,  0, 60,  0, 60,  0 ]\n].reverse());\n\n// offensive lines\ndefaultEvaluator.addFormation([\n  [  0,  0, +3 ],\n  [ +1, -1, +3 ]\n], [\n  [  0, 12,  0,  8,  0,  0,  0,  0 ],\n  [ 12,  0, 10,  0,  6,  0,  0,  0 ],\n  [  0, 10,  0,  8,  0,  4,  0,  0 ],\n  [  8,  0,  8,  0,  6,  0,  2,  0 ],\n  [  0,  6,  0,  6,  0,  4,  0,  0 ],\n  [  0,  0,  4,  0,  4,  0,  2,  0 ],\n  [  0,  0,  0,  2,  0,  2,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ]\n].reverse());\n\n// offensive 3-lines\ndefaultEvaluator.addFormation([\n  [  0,  0, +3 ],\n  [ +1, -1, +3 ],\n  [ +2, -2, +3 ]\n], [\n  [  0, 12,  0,  8,  0,  0,  0,  0 ],\n  [ 12,  0, 10,  0,  6,  0,  0,  0 ],\n  [  0, 10,  0,  8,  0,  4,  0,  0 ],\n  [  8,  0,  8,  0,  6,  0,  0,  0 ],\n  [  0,  6,  0,  6,  0,  4,  0,  0 ],\n  [  0,  0,  4,  0,  4,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ]\n].reverse());\n\n// triangle bases\ndefaultEvaluator.addFormation([\n  [  0,  0, +3 ],\n  [ +1, -1, +3 ],\n  [ -1, -1, +3 ]\n], [\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [  0,  0, 12,  0,  8,  0,  4,  0 ],\n  [  0,  8,  0, 12,  0,  8,  0,  0 ],\n  [  0,  0,  8,  0, 12,  0,  8,  0 ],\n  [  0,  4,  0, 12,  0, 12,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ]\n].reverse());\n\n// defensive lines\ndefaultEvaluator.addFormation([\n  [  0,  0, +3 ],\n  [ -1, -1, +3 ]\n], [\n  [  0,  0,  0,  0,  0, 10,  0, 16 ],\n  [  0,  0,  0,  0,  8,  0, 12,  0 ],\n  [  0,  0,  0,  6,  0, 10,  0, 10 ],\n  [  0,  0,  4,  0,  8,  0,  8,  0 ],\n  [  0,  2,  0,  6,  0,  6,  0,  0 ],\n  [  0,  0,  4,  0,  4,  0,  0,  0 ],\n  [  0,  2,  0,  2,  0,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ]\n].reverse());\n\n// defensive 3-lines\ndefaultEvaluator.addFormation([\n  [  0,  0, +3 ],\n  [ -1, -1, +3 ],\n  [ -2, -2, +3 ]\n], [\n  [  0,  0,  0,  0,  0, 10,  0, 16 ],\n  [  0,  0,  0,  0,  8,  0, 12,  0 ],\n  [  0,  0,  0,  6,  0, 10,  0, 10 ],\n  [  0,  0,  4,  0,  8,  0,  8,  0 ],\n  [  0,  0,  0,  6,  0,  6,  0,  0 ],\n  [  0,  0,  4,  0,  4,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ],\n  [  0,  0,  0,  0,  0,  0,  0,  0 ]\n].reverse());\n\nexport default defaultEvaluator;\n\n\n\n// WEBPACK FOOTER //\n// src/core/default_evaluator.js","'use strict';\n\nexport default class Evaluator {\n  constructor() {\n    // rules are represented as a 2D array of [pattern, score] pairs, where:\n    //  - `pattern` is an array of [dx, dy, value] pairs, and\n    //  - `score` is what will be awarded if the pattern matches\n    this.rules = [ [], [], [], [], [], [], [], [] ];\n  }\n\n  addFormation(formation, scores) {\n    // `formation` takes the form [[dx, dy, v], [dx, dy, v], ...], where:\n    //  - (dx, dy) is the offset from the origin of the formation, and\n    //  - v is the value to match against:\n    //    -  0: an empty square\n    //    - +1: a regular piece on my side\n    //    - +2: a king on my side\n    //    - +3: any piece on my side\n    //    - -1: a regular piece on my opponent's side\n    //    - -2: a king on my opponent's side\n    //    - -3: any piece on my opponent's side\n    // `scores` is an 8x8 array of values representing the bonus (or penalty)\n    //    awarded when the formation's origin matches the given position\n    let rules = this.rules;\n\n    // push on the pattern and score for each non-zero slot\n    for (let y = 0; y < 8; ++y) {\n      for (let x = 0; x < 8; ++x) {\n        let score = scores[y][x];\n\n        if (score != 0) {\n          rules[y][x] = (rules[y][x] || []);\n          rules[y][x].push([formation, score]);\n        }\n      }\n    }\n  }\n\n  evaluate(board) {\n    // match the board and side against the formations and return a score:\n    //  - for each square on the board, get the set of formations on it\n    //  - for each formation, see if it applies to red (+) from the top of\n    //      the board, or white (-) from the bottom, and adjust the total\n    //      score accordingly\n    let { rules } = this,\n        total = 0;\n\n    for (let y = 0; y < 8; ++y) {\n      for (let x = 0; x < 8; ++x) {\n        let r = rules[y][x];\n\n        if (r) {\n          for (let j = 0; j < r.length; ++j) {\n            let [formation, score] = r[j], match;\n\n            // try the pattern as red\n            match = true;\n            for (let k = 0; k < formation.length; ++k) {\n              let [dx, dy, v] = formation[k],\n                  p = board[y + dy][x + dx];\n\n              // see if the formation matches for this square\n              if (!((v == 0 && p == 0) ||\n                    ((v == +1 || v == +3) && p == +1) ||\n                    ((v == +2 || v == +3) && p == +2) ||\n                    ((v == -1 || v == -3) && p == -1) ||\n                    ((v == -2 || v == -3) && p == -2))) {\n                // bail out and flag as failed\n                match = false;\n                break;\n              }\n            }\n            if (match) {\n              total += score;\n            }\n\n            // try the pattern as white\n            match = true;\n            for (let k = 0; k < formation.length; ++k) {\n              let [dx, dy, v] = formation[k],\n                  p = board[(y ^ 7) - dy][(x ^ 7) - dx];\n\n              // see if the pattern matches for this square\n              if (!((v == 0 && p == 0) ||\n                    ((v == +1 || v == +3) && p == -1) ||\n                    ((v == +2 || v == +3) && p == -2) ||\n                    ((v == -1 || v == -3) && p == +1) ||\n                    ((v == -2 || v == -3) && p == +2))) {\n                // bail out and flag as failed\n                match = false;\n                break;\n              }\n            }\n            if (match) {\n              total -= score;\n            }\n          }\n        }\n      }\n    }\n\n    return total;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// src/core/evaluator.js","import Analyzer from './core/analyzer';\n\naddEventListener('message', ev => {\n  let { board, side } = ev.data, analyzer = new Analyzer(board, side);\n  postMessage({ move: analyzer.run()[0] });\n}, false);\n\n\n\n// WEBPACK FOOTER //\n// src/worker.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChEA;AACA;;;;;;;;;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AA/OA;;;;;;;;ACFA;AACA;;;;;;;;AACA;AACA;;;AAAA;AACA;;;;;;;;;;;AACA;;;AACA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AAPA;AAQA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAtFA;;;;;;;;ACLA;AACA;;;;;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AAYA;AACA;AACA;AAaA;AACA;AACA;AAcA;AACA;AACA;AAcA;AACA;AACA;AAaA;AACA;AACA;AAcA;;;;;;;;AChHA;AACA;;;;;;;;;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AADA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AADA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AApGA;;;;;;;;;;ACFA;AACA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;A","sourceRoot":""}